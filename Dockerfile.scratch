# =================================================================
#  第一阶段：构建环境 (Builder)
#  目标：编译一个完全静态链接、自包含的 Nginx 可执行文件
# =================================================================
FROM alpine:latest AS builder

WORKDIR /tmp

# --- 原子化构建指令 ---
RUN set -eux && \
    # --- 1. 安装构建时依赖 ---
    # 注意：这里不需要 pcre-dev 或 zlib-dev，因为我们将从源码编译
    apk add --no-cache \
        build-base \
        curl \
        perl \
        sed \
        grep \
        tar \
        bash \
        linux-headers \
    && \
    # --- 2. 获取所有组件的最新版本号 (使用您正确的 grep -oE 方法) ---
    NGINX_VERSION=$(curl -s https://nginx.org/en/download.html | grep -oE 'nginx-[0-9]+\.[0-9]+\.[0-9]+' | head -n1 | cut -d'-' -f2) && \
    OPENSSL_VERSION=$(wget -q -O - https://www.openssl.org/source/ | grep -oE 'openssl-[0-9]+\.[0-9]+\.[0-9]+' | head -n1 | cut -d'-' -f2) && \
    ZLIB_VERSION=$(curl -s https://zlib.net/ | grep -oE 'zlib-[0-9]+\.[0-9]+\.[0-9]+' | head -n1 | cut -d'-' -f2) && \
    PCRE_VERSION=$(curl -sL https://sourceforge.net/projects/pcre/files/pcre/ | grep -oE 'pcre-[0-9]+\.[0-9]+' | cut -d'-' -f2 | sort -Vr | head -n1) && \
    \
    echo "============= 版本号 =============" && \
    echo "NGINX_VERSION=${NGINX_VERSION}" && \
    echo "OPENSSL_VERSION=${OPENSSL_VERSION}" && \
    echo "ZLIB_VERSION=${ZLIB_VERSION}" && \
    echo "PCRE_VERSION=${PCRE_VERSION}" && \
    \
    # --- 3. 下载所有源码 ---
    curl -fSL https://nginx.org/download/nginx-${NGINX_VERSION}.tar.gz -o nginx.tar.gz && \
    curl -fSL https://www.openssl.org/source/openssl-${OPENSSL_VERSION}.tar.gz -o openssl.tar.gz && \
    curl -fSL https://zlib.net/zlib-${ZLIB_VERSION}.tar.gz -o zlib.tar.gz && \
    curl -fSL https://downloads.sourceforge.net/project/pcre/pcre/${PCRE_VERSION}/pcre-${PCRE_VERSION}.tar.gz -o pcre.tar.gz && \
    \
    # --- 4. 解压所有源码 ---
    tar xzf nginx.tar.gz && \
    tar xzf openssl.tar.gz && \
    tar xzf zlib.tar.gz && \
    tar xzf pcre.tar.gz && \
    \
    # --- 5. 编译 Nginx (静态链接) ---
    cd nginx-${NGINX_VERSION} && \
    ./configure \
        --prefix=/etc/nginx \
        --user=nginx \
        --group=nginx \
        --with-compat \
        --with-threads \
        --with-http_ssl_module \
        --with-http_v2_module \
        --with-http_gzip_static_module \
        --with-http_stub_status_module \
        --with-pcre-jit \
        # 指向源码目录
        --with-pcre=../pcre-${PCRE_VERSION} \
        --with-zlib=../zlib-${ZLIB_VERSION} \
        --with-openssl=../openssl-${OPENSSL_VERSION} \
        # 这是实现 scratch 的关键：将所有库静态链接进 Nginx
        --with-ld-opt="-static" && \
    make -j$(nproc) && \
    make install && \
    # strip 可执行文件以进一步减小体积
    strip /etc/nginx/sbin/nginx

# =================================================================
#  第二阶段：最终镜像 (Final Image)
#  使用我们最初的目标：scratch
# =================================================================
FROM scratch

# 从 builder 阶段拷贝所有需要的文件
# 1. 静态编译的 Nginx 可执行文件
COPY --from=builder /etc/nginx/sbin/nginx /usr/sbin/nginx
# 2. Nginx 配置文件
COPY --from=builder /etc/nginx/conf /etc/nginx/conf
# 3. 默认的网页文件
COPY --from=builder /etc/nginx/html /etc/nginx/html
# 4. 运行 Nginx 所需的用户和组信息
COPY --from=builder /etc/passwd /etc/passwd
COPY --from=builder /etc/group /etc/group

# 创建 Nginx 需要的临时目录
# 注意：在 scratch 镜像中，我们无法运行 chown，所以这些目录将属于 root。
# 但由于 Nginx 是以 nginx 用户运行，它需要有权限写入。
# 通常的解决方案是在启动脚本中处理，或者在 k8s 等环境中通过 emptyDir volume 挂载。
# 为了简单起见，这里我们先创建目录。
RUN mkdir -p /var/cache/nginx

# 暴露端口
EXPOSE 80 443

# 切换到非 root 用户
USER nginx

# 启动 Nginx
CMD ["/usr/sbin/nginx", "-g", "daemon off;"]
